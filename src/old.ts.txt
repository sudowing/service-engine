/*
//  * -- UNIQUE Resources occur at /service/resource/record?pk=1
//  * CREATE (one & many)
//  * READ (unique & search as `search`)
//  * UPDATE (unique & many)
//  * DELETE (unique & many) (soft & hard)
//  *
//  * NOTE: pass in query -- get errors or knex object
//  */
// export const generateOperations = ({
//   db,
//   st,
//   validator,
//   resource,
// }: ts.IParamsGenerateOperations) => {
//   const { schema, meta } = validationExpander(validator);
//   const processCreate = ({ query, requestId }: ts.IParamsProcessBase) => {
//     const { error, value: query } = validateOneOrMany(schema.create, payload);
//     if (error) return _reject(error);
//     const sql = toCreateQuery({ db, st, resource, query, context });
//     return _resolve({ sql });
//   };

//   const processRead = ({ query, requestId }: ts.IParamsProcessBase) => {
//     const { error, value: query } = schema.read.validate(payload);
//     if (error) return _reject(error);
//     const sql = toReadQuery({ db, st, resource, query, context });
//     return _resolve({ sql });
//   };
//   const processUpdate = ({
//     payload,
//     context,
//     searchQuery,
//   }: ts.IParamsProcessWithSearch) => {
//     const { error, value: query } = validateOneOrMany(schema.update, payload);
//     if (error) return _reject(error);
//     if (searchQuery) {
//       const validSearch = schema.search.validate(searchQuery);
//       if (validSearch.error) _reject(validSearch.error);
//     }
//     const sql = toUpdateQuery({
//       db,
//       st,
//       resource,
//       query,
//       context,
//       searchQuery,
//     });
//     return _resolve({ sql });
//   };
//   // soft delete VS hard delete defined by db query fn
//   const processDelete = ({
//     payload,
//     context,
//     searchQuery,
//     hardDelete,
//   }: ts.IParamsProcessDelete) => {
//     const { error, value: query } = validateOneOrMany(schema.update, payload);
//     if (error) return _reject(error);
//     if (searchQuery) {
//       const validSearch = schema.search.validate(searchQuery);
//       if (validSearch.error) _reject(validSearch.error);
//     }
//     const sql = toDeleteQuery({
//       db,
//       st,
//       resource,
//       query,
//       context,
//       searchQuery,
//       hardDelete,
//     });
//     return _resolve({ sql });
//   };
//   const processSearch = (payload: any) => {
//     // validation (schema.search.validate) occurs inside QueryParser
//     const { errors, components, context } = meta.searchQueryParser(payload);
//     if (errors) return _reject(errors);
//     const sql = toSearchQuery({ db, st, resource, context, components });
//     return _resolve({ sql });
//   };

//   return {
//     create: processCreate,
//     read: processRead,
//     update: processUpdate,
//     del: processDelete,
//     search: processSearch,
//   };
// };
