import * as Router from '@koa/router'
import * as HTTP_STATUS from 'http-status';
import * as engine from 'service-engine';

import { db, st } from './network-resources'
import {createLogger} from "bunyan";


const seperateQueryAndContext = (input) =>
  Object.entries(input)
    .reduce((query, [key, value]) => {
      const info = key.startsWith('|') ? query.context : query.payload;
      info[key.replace('|', '')] = value;
      return query;
    }, {payload: {}, context: {},});



const logger = createLogger({
  name: 'myapp.controller',
  level: 0,
});

const j = JSON.stringify; // convience
const operations = new Map();
operations.set(j({method: 'POST', record: false}), 'create');
operations.set(j({method: 'GET', record: false}), 'search');
operations.set(j({method: 'PUT', record: true}), 'update');
operations.set(j({method: 'DELETE', record: true}), 'delete');
operations.set(j({method: 'GET', record: true}), 'read');



export const serviceRouters = async() => {
  const router = new Router();

  const { validators ,dbResources } = await engine.genDatabaseResourceValidators({ db });
  const { rows: dbResourceRawRows } = await db.raw(engine.getDatabaseResources({ db }))
  const apiDocs = await engine.genDatabaseResourceOpenApiDocs({db, st, logger});


  router.get('/ping', (ctx) => {
    ctx.response.body = { hello: "world", now: Date.now() }
  });
  
  
  router.get('/openapi', async (ctx) => {
    ctx.response.body = apiDocs;
  });
  
  router.get('/db_resources', async (ctx) => {
    ctx.response.body = dbResources;
  });
  
  
  router.get('/db_resources/raw', async (ctx) => {
    ctx.response.body = dbResourceRawRows;
  });
  
  router.get('/resources', async (ctx) => {
    const resources = Object.entries(validators)
      .reduce((batch, [name, validator]: any) => ({
        ...batch,
        [name]: new engine.Resource({db, st, logger, name, validator}).report
      }), {});
    ctx.response.body = resources;
  });
  
  

  const serviceView = async (ctx) => {
  
    const requestId = engine.uuid();
  
    // '/:category/:resource/record
    const { category, resource } = ctx.params;
    const method = ctx.method;
    const url = ctx.request.url;
    const record = url.endsWith('/record');
  
  
    // only process for /service & /debug
    if (category !== 'service' && category !== 'debug') {
      ctx.response.status = HTTP_STATUS.NOT_FOUND;
      return
    }
  
  
    const resources = Object.entries(validators)
      .reduce((batch, [name, validator]: any) => ({
        ...batch,
        [name]: new engine.Resource({db, st, logger, name, validator})
      }), {});
  
    // only process for /service & /debug && only if resource exists and operation on resource exists
    if (
      (category !== 'service' && category !== 'debug')
      ||
      !operations.has(j({method, record}))
      ||
      !resources.hasOwnProperty(resource)
      ) {
      ctx.response.status = HTTP_STATUS.NOT_FOUND;
      return
    }
  
    const operation = operations.get(j({method, record}));

    const input = method === 'GET'
      ? seperateQueryAndContext(ctx.request.query)
      : { payload: ctx.request.body || {} };
  
    const serviceResponse = resources[resource][operation]({...input, requestId});
  
  
    // create(input: ts.IParamsProcessBase) {
    // read(input: ts.IParamsProcessBase) {
    // update(input: ts.IParamsProcessWithSearch) {
    // delete(input: ts.IParamsProcessDelete) {
    // search(input: ts.IParamsProcessBase) {
  
    // IParamsProcessBase
    //   payload: any;
    //   context?: any;
    //   requestId: string;
    
    // IParamsProcessWithSearch extends IParamsProcessBase
    //   searchQuery?: any;
    
    // IParamsProcessDelete extends IParamsProcessWithSearch
    //   hardDelete?: boolean;
    
    // insert db, components
    if (serviceResponse.result) {
      serviceResponse.result.sqlString = serviceResponse.result.sql.toString();
      serviceResponse.result.data = await serviceResponse.result.sql;
      delete serviceResponse.result.sql;
    }
    
    ctx.response.body = {
      now: Date.now(),
      requestId,
      url,
      record,
      method,
      category,
      resource,
      operation,
      input,
      serviceResponse
    };
    
  };
  
  
  router.get('/:category/:resource', serviceView);
  router.post('/:category/:resource', serviceView);
  
  router.get('/:category/:resource/record', serviceView);
  router.post('/:category/:resource/record', serviceView);
  router.put('/:category/:resource/record', serviceView);
  router.delete('/:category/:resource/record', serviceView);

  return {router};
};













































import * as cors from "@koa/cors";
// import { ApolloServer } from "apollo-server-koa";
// import * as config from 'config';

import * as Koa from "koa";
import * as bodyParser from "koa-bodyparser";
import * as compress from "koa-compress";

import {createLogger} from "bunyan";

var logger = createLogger({name: 'myapp'});


import { serviceRouters } from "./controllers";


// const port = config.get("port") || 3001;
const port = 3001;

// router.prefix(`/service`);


const main = async () => {

    const {router} = await serviceRouters();

    const App = new Koa();

    App.use(cors());
    
    App.use(bodyParser())
        .use(router.routes())
        .use(router.allowedMethods())
    
    App.use(compress());
    
    App.listen({ port }, () => {
        logger.info({ port }, "App Started.");
    });
};

main();